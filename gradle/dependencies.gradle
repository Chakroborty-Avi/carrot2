allprojects {
  def consolidatedConfigurations = project.configurations.matching {
    it.name in [
      "annotationProcessor",
      "compileClasspath",
      "runtimeClasspath",
      "testCompileClasspath",
      "testRuntimeClasspath",
      "testFixturesClasspath",
      "langResources"
    ]
  }

  dependencyVersionChecks {
    lockFileComment = "An inventory of resolved dependency versions. Do not edit this file directly."
    configurationGroups {
      create("all", {
        include provider {
          consolidatedConfigurations.collect {
            it.name
          }
        }
      })
    }
  }

  dependencies {
    constraints {
      consolidatedConfigurations.configureEach { Configuration conf ->
        add(conf.name, libs.log4j.slf4j2, {
          because("Use consistent log4j version.")
        })
        add(conf.name, libs.log4j.core, {
          because("Use consistent log4j version.")
        })
        add(conf.name, libs.slf4j.api, {
          because("Use consistent slf4j version.")
        })
        add(conf.name, libs.junit, {
          because("Use consistent JUnit version.")
        })
        add(conf.name, libs.bytebuddy, {
          because("Use consistent ByteBuddy version.")
        })
      }
    }
  }
}

// Configure dependency updates to not accept any odd versions.

def isNonStable = { String version ->
  def stableKeyword = [
    'RELEASE',
    'FINAL',
    'GA'
  ].any { it -> version.toUpperCase(Locale.ROOT).contains(it) }
  def regex = /^[0-9,.v-]+(-r)?$/
  return !stableKeyword && !(version ==~ regex)
}

tasks.named("dependencyUpdates").configure {
  rejectVersionIf {
    isNonStable(it.candidate.version)
  }
}
